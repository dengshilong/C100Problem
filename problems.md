# chapter1
## 1.1 最长平台问题(Pleateau)
已知一个已经从小到大排序的数组，这个数组中的一个平台(plateau) 就是连续的一串相同的元素，并且这一串元素不能再延伸。

例如，在1，2，2，3，3，3，4，5，5，6中1，2.2，3.3.3，4，5.5，6都是平台。试编写一个程序，接受一个数组，把这个数组中最长的平台找出来。

在上面的例子中，3.3.3就是该数组的最长平台。

说明:
这个程序十分简单，但是要编写号却不容易，因此在编写程序时应该考虑下面几点：

1. 使用的变量越少越好
2. 能否只把数组的元素每一个只查一次就得到结果？
3. 程序语句越少越好。

这个问题曾经困扰过 David Gries这位知名的技术机科学家。本题与解答取自David Gries编写的有光程序设计的专著。

解答见[pleateau.py](https://github.com/dengshilong/C100Problem/blob/master/chapter1/pleateau.py)

## 1.2 支配值数目(GTCount)
已知f[]与g[]两个整数数组，元素已经从小到大排列，请写一个程序，算出f[]中比g[]元素大的对数。换句话说，f[0]比g[]中多少个元素大，f[1]比g[]中多少元素大等，这些值的总和就是要求的答案。

例如，如果f[]中有1，3，5，7，9，而g[]中有2，3，4，7，8，比g[0]大的有f[1]~f[4], 比g[1]大的有f[2]~f[4]，比g[2]大的有f[2]~f[4]，比g[3]大的有f[4]，比g[4]大的有f[4]，因此答案是4 + 3 + 3 + 1 + 1 = 12

说明: 与问题1.1一样，需要特别注意数组f[]与g[]已经排序。如果问题1.1能够做出完美的解答，那么本题也不难，相似的方法就可以得到高效率的程序。

利用数组已经排好序的这个特性，可以写出高效的程序. 解答见[gt_count.py](https://github.com/dengshilong/C100Problem/blob/master/chapter1/gt_count.py)


## 1.3 等值数目(EQCount)
已知两个整数数组f[]与g[]，它们的元素都已经从小到大排列好，而且两个数组中的元素都各不相同。例如，f[]中有1,3,4,7,9,而g[]中有3,5,7,8,10。试编写程序算出这两个数组之间有多少组相同的元素。

就上例而言，f[2]和g[1]为3是一组​; f[3]与g[2]为7是第二组

说明: 建议不要使用下面的方法来编程

1. 固定f[i]
2. 对于f[i]而言，检查g[]中是否有与f[i]相同的元素
3. 处理下一个f[i], 即f[i + 1]

因为f[]与g[]都已经从小到大排列好，所以应该活用这一个很强的特性。一个好的程序员绝对不应用上面的笨拙方法来编写程序, 这样会做太多无意义的事。为什么呢？因为g[]的元素都相异，对于f[i]而言，最多只会找出一个与它相同的元素，最坏的情况时把g[]全部查完才找出相同元素(如果采用上面的方法), 如果g[]中有n个元素，需要查n次; 但是若f[]中也有n个元素，那么需要把g[]查n遍，一共作n ** 2(Python的记法，即n的2次方)次比较才能找出结果。

试着找出一种方法，把f[]与g[]各查一次就可以得到答案(记住, 活用f[]与g[]已经从小到大排列的特性).

做完这一题后，建议继续作下一题。

依然是利用已经排好序的这个特性。解答见[eq_count.py](https://github.com/dengshilong/C100Problem/blob/master/chapter1/eq_count.py)

## 1.4 两数组最短距离(MinDist)
已知两个元素从小到大排列的数组x[]与y[],请编写一个程序算出两个数组元素彼此之间差的绝对值最小的一个数，此值称为数组的距离。

说明： 如果x[i]与y[i]是两个元素，那么 |x[i] - y[i]| 就是这两个元素之间的距离，所有这些距离的最小值，称为数组的距离。比如说x[]有1，3，5，7，9， y[]有2，6，8，那么最短距离就是1，因为x[0]与y[0]、 x[1]与y[0]、x[2]与y[1]、x[3]与y[1]、还有x[4]与y[2]的距离都是1。

注意，如果x[]与y[]各有m与n个元素，那么元素之间的距离就一共有m * n个; 事实上往往用不着这么多个值，应该活用x[]与y[]已经排列好的特性，不要把所有的距离都算出来。

依然是利用数组已经排好序的特性。解答见[min_dist.py](https://github.com/dengshilong/C100Problem/blob/master/chapter1/min_dist.py)

## 1.5 等值首尾和(HeadTail)
假设有一个数组x[ ], 它有n个元素，每一个都大于零，称x[0] + x[1] + … + x[i]为前置和(Prefix Sum),而 x[j] + x[j + 1] + … + x[n - 1]为后置和(Suffix Sum)。试编写一个程序，求出x[ ] 中有多少组相同的前置和与后置和。

说明: 如果x[ ] 的元素是3，6，2，1，4，5，2，则x[ ]的前置和有一下7个，即3，9，11，12，16，21，23；后置和则是2，7，11，12，14，20，23；于是11，12，与23这3对就是值相同的前置和与后置和，因为：

> 11 = 3 + 6 + 2(前置和) = 2 + 5 + 4 (后置和)
>
>12 = 3 + 6 + 2 + 1(前置和) = 2 + 5 + 4 + 1 (后置和)

因为23是整个数组元素的和，因此前置和与后置和一定相同。

当然，也可以用上面的方法把前置和与后置和都算出来(两者都是从小到大的递增序列, 为什么?), 再进行比较, 但建议不要使用这种方法, 因为它需要额外的内存。

可以用变量prefix来表示前置和，用suffix来表示后置和，用i表示前置和累加元素的位置，i从前往后加，用j表示后置和累加元素的位置, j从后往前加。当prefix > suffix时，累加后置和，也就是j向前走；当prefix < suffix时，累加前置和，也就是i往后走；当prefix == suffix时，同时累加前置和与后置和，也就是i往后走，j往前走. 解答见[head_tail.py](https://github.com/dengshilong/C100Problem/blob/master/chapter1/head_tail.py)

# chapter2

## 2.3 求质数(PrimeOne)
试编写一个程序，找出前 N(如200)个质数。如果没有进一步要求，这不是难题。但再次希望从所知的、使用除法的方法中，用最快的办法来编写程序.

说明: 可能最先想到的办法，就是让某个变量 i 从 2 变到 N，然后检查它是不是质数，如果是就显示出来，如果不是，就检查下一个。这是正确的做法，但却没有注意到一个小细节，因而使程序运行速度变慢。当然，2是质数，但所有 2 的倍数都不是质数，如果令 i 从 2 变到 N, 不就很冤枉的测试了 4,6,8,10,...这些数? 所以第一点提示是测试 2,3,5,7,...,N, 即 2 与所有奇数就足够了。同理，3 是质数，但 6,9,12,...这些3的倍数却不是，因此，如果能把 2 与 3的倍数都跳过去而不测试，任意连续的 6个数中，就只会测试两个而已。以6n,6n + 1,6n + 2, 6n + 3, 6n + 4, 6n + 5为例，6n, 6n + 2, 6n + 4是偶数, 6n + 3是3的倍数, 所以如果把 2 与 3 的倍数都不理会，要测试的数就只留下6n + 1与6n + 5而已，因而工作量之时前述想法的2 / 6 = 1/3, 应该用这个办法去编写程序。

假如i 是如上述的一个数(不是2 与 3 的倍数), 如何测试 i 是个质数呢? 按照定义 i 如果是质数, 也就只有 1 与 i 可以除尽自己，所以可以用2, 3, 4, 5, 6, ..., i - 1去除 i, 如果都除不尽(余数不是0), i 就是质数。观点也对，但却与上一点一样地笨拙。当 i > 2 时，有哪一个数 i 可以被 i - 1除尽的? 没有, 为什么? 如果 i 不是质数, 那么 i = a * b, 此地 a 与 b 既不是 i 又不是 1; 正因为 a > 1, a 至少是2， 因此 b 最多是 i / 2而已，去除 i 的数用不着是 2,3,4,...,i - 1, 而用 2,3,4,..., i / 2就可以了。 不但如此，因为 i = a * b, a 与 b 不能大于sqrt(i)(即i的平凡根), 为什么呢? 如果a > i 的平方根, b > i 的平方根, 于是a * b > i, 因此就都不能整除i了。如果 i 不是质数, 它的最大因子就是sqrt(i)； 换言之，用2,3,4,5,...,sqrt(i)去除 i 就行了。

但是, 用2,3,4,5,...,sqrt(i)去除i也是个浪费。就像前一段所说的，2除不尽，2的倍数也除不尽；同理 3 除不尽，3 的倍数也除不尽......最理想的方法就是用质数去除 i, 因为在前一段的提示， i 不是 2 与 3的倍数，所以就用5, 7, 11, 13, 17, 19,...这些比sqrt(i)小的质数去除 i 即可。

但问题是这些质数从何而来? 这比较简单，可以准备一个数组prime[], 用于存放找出来的质数, 一开始它应该有2 、3与5。于是当 i = 5,7,11,13,17,19,23,25,29,...这些不是 2 与 3 的倍数时，就用prime[]中小于 sqrt(i)的数去除 i 即可，如果都除不尽，i 就是质数，把它放入prime[]中，因此prime[]中的质数就会越来越多，直到满足所要的个数为止。

不妨用这段说明来编写程序，不过应注意下面几点:

1. 不要处理2 与 3 的倍数(见第一段)
2. 用质数去除(见第二、三段).
3. 用i的平方根可能会有问题，为什么?有什么办法可以解决?

解答见[prime_one.py](https://github.com/dengshilong/C100Problem/blob/master/chapter2/prime_one.py)

## 2.4 筛法(SIEVE)
求质数是一个很普遍的问题, 通常不外乎用数去除, 到除不尽时, 给定的数就是质数。但是早在2000年前人们就知道了一个不必用除法而找出2~N的质数的所有方法了。假设有一个很神奇的筛子, 可以给出一个数,例如 i,这个筛子有办法把 i 的所有倍数去掉。请用这个方法求出2~N之间的所有质数。这个方法称为 Eratosthenes(人名)筛法(Sieve Mothod)

说明:下面通过一个例子来加强对筛法的印象,求出2~40之间的质数。首先,把2~40这
些数一字排开:

2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40

2是质数, 所以把2的倍数都筛掉

3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39

下一个数自然是质数3, 所以把3的倍数都筛掉

5 7 11 13 17 19 23 25 29 31 35 37

下一个是5, 把5的倍数筛掉

7 11 13 17 19 23 29 31 37

下一个是7, 把7的倍数筛掉(其实在此之前都已经筛掉了)

11 13 17 19 23 29 31 37

再下来是11, 比20/2大了, 所以工作停止, 没有被筛掉的就是质数, 它们是2,3.5,
7,11,13,17,19,23,29,31,37。

可以按照这一逻辑来编写程序,但是需注意下面几点:

1. 2是质数,所以2的倍数是一定会被删除的,所以在一开始时根本没有把2的倍
数放到筛子中的必要,这就省下了一半的空间。

2. 如果要求2~N之间的质数,做到N/2就可以停下来,因为大过N/2的数都不可
能整除N

3. 程序不可以使用乘法与除法,只能用加或减,以求加快速度。

请基于这3项要求来编制程序。

解答见[sieve.py](https://github.com/dengshilong/C100Problem/blob/master/chapter2/sieve.py)

## 2.6 因子分解(FACTOR)

编写一个程序, 读入一个正整数, 把它的所有质因子找出来。例如, 如果输入的是72 = (2 ^ 3) * (3 ^ 2),于是质因子就有 2 与 3, 如果输入的是181944, 181944 = (2 ^ 3) * (3 ^ 2) * 7 * (19 ^ 2), 因子为2、3、7与19。为了方便起见,(2 ^ 3) * (3 ^ 2) * 7 * (19 ^ 2)可以用2(3)3(2)7(1)19(2)作为输出形式, 也就是说,如果分解开来有a ^ b,输出时就是a(b)。

说明: 传统的做法是把输入值(假设是n)用2去除,一直到除不尽为止。如果一共除了i次就有2 ^ i这一项,输出中就会出现2(i); 接着再用3去除、5去除、7去除等,直到商数变成1为止。以181944为例,第一次用2除得到93972, 再除一次是46896, 第三次得到23493,于是2就不能整除了。下来用3去除, 第一次得到7831, 第二次是2527, 第三次就不能整除。对于2527而言, 用7去除得到361, 再用7就除不尽了, 其次的11、13、15、17也都除不尽; 但19可以, 再用19去除得19; 最后用19除, 商为1, 不能再除了,因此就得到181944 = (2 ^ 3) * (3 ^ 2) * 7 * (19 ^ 2)的结果。试用这个概念来编写程序。

解答见[factor.py](https://github.com/dengshilong/C100Problem/blob/master/chapter2/factor.py)


## 2.7 数值自乘递归解(RecursionPower)
如果n与m是正整数, 那么m ** n 就是把m连乘n次, 这是一个效率很低的方法，请写一个计算效率高的程序 ，并且分析城中一共用了多少个乘法，应该以n - 1个乘法作为设计准则。

说明: 这是一个典型的递归设计题目，应该注意一下几点

1. 试用分而治之(Divide and Conquere)的策略
2. 注意到x ^ 4可以用x ^ 2自乘的关系，由此可以大量地降低乘法数目
3. 连乘n次要n - 1个乘法，能做到只要2log(n)个乘法吗？

解答见[recursion_power.py](https://github.com/dengshilong/C100Problem/blob/master/chapter2/recursion_power.py)

## 2.8 数值自乘非递归解( IterationPower)
继续求m ^ n 问题(m与n是正整数)。前面的数值自乘递归解会得到一个递归的程序,请编制一个运算效率同样高的非递归的程序。

说明: 或许读者有自己独特的看法, 但在此提供一个简单的建议, 可以采用它来编写程序, 当然也可以把它化简。建议是把指数n用二进制来看, 比如若n=13, 那么13(10进制)=1101(2进制)=2 ^ 3 + 2 ^ 1 + 2 ^ 0, 所以求m ^ (2 ^ 3 + 2 ^ 1 + 2 ^ 0)时就相当于求m ^ (2 ^ 3) * m ^ (2 ^ 2) * m ^ (2 ^ 0);会发现二进制表示中对应那一位是1, 在m中就有那么一项。把这个观念编制成程序。

另外一个办法是可以把递归解法中每一个递归步骤的n提出来,看在什么时候用(m ^ k) ^ 2,什么时候用m(m ^ 2k),然后用非递归方式写出来。

了解了这些观点之后,编写这个程序就不难了。在编写完程序之后,还应该分析一下程序乘了多少次。

解答见［iteration_power.py](https://github.com/dengshilong/C100Problem/blob/master/chapter2/iteration_power.py)

## 2.9 Fibonacci数非递归解(IterationFibonacci)
Fibonacci数列f(1),f(2),...,f(n)的定义是:

1. f(n) = 1 当 n = 1或n = 2时
2. f(n) = f(n-1) + f(n-2) 当n > 2时

不用递归的方法, 也不用数组, 编写一个函数, 它接收n的值, 返回f(n)。

说明: 用递归方法算 Fibonacci数列效率是很低的, 要计算很多个重复的加法, 这个题目要求不用递归, 不用数组, 把f(n)求出来。 不过应注意下面的事项:

1. 递归方式并非全然不好,但不能直接套用公式。
2. 因为当n > 2时,f(n) = f(n-1) + f(n-2),所以程序只保留f(n-1)与f(n-2)就可以算出f(n)。

解答见[iteration_fibonacci.py](https://github.com/dengshilong/C100Problem/blob/master/chapter2/iteration_fibonacci.py)

## 2.10 快速Fibonacci数算法(FastFibonacci)

继续讨论Fibonacci 数列问题。在非递归的Fibonacci 程序中，在算f(n)时最多不超过n - 2个加法, 编写一个速度更快的程序，或许可以用乘法。如果每一个乘法用m单位时间, 每一个加法用p单位时间，于是非递归的写法因为最多有n - 2个加法，因此最多用(n-2)p时间。请问，改善的程序要用多少时间？假设只考虑加法与乘法而已。

说明: 解决这个问题的技巧不少，在此先提示一个很容易理解的方法。用矩阵来算，看下面的式子:

(f(n), f(n-1)) = ((1, 1), (1, 0)) * (f(n-1)), f(n-2)), n > 2
相信不难看出这个式子是对的，其实这只不过是把: f(n) = f(n-1) + f(n-2), f(n-1) = f(n-1)写成矩阵的形式而已。

将上式展开:
(f(n-1),f(n-2)) = ((1, 1), (1, 0))*(((1, 1), (1, 0)) * (f(n-2), f(n-3))) = ((1, 1), (1, 0)) ^ 2  * (f(n-2), f(n-3))

一般而言，有:
(f(n), f(n-1)) = ((1, 1),(1,0)) ^ i * (f(n-i), f(n-i-1))
继续展开会得到:
(f(n), f(n-1))=((1,1),(1,0))^(n-2) * (f(2), f(1)) = ((1,1),(1,0))^(n-2) * (1, 1)

可以用这个观点来编写程序。

解答见[iteration_fibonacci.py](https://github.com/dengshilong/C100Problem/blob/master/chapter2/fast_fibonacci.py)

## 2.11 扩充Fibonacci数(ExtendFibonacci)

定义一组称为扩充的Fibonacci数如下:
已知X 与 Y两个数, 于是扩充Fibonacci数F(i)为
F(i) = 1 当i=0或者i=1, F(i) = X * F(i-2) + Y * F(i-1) i > 1
因此，当X=Y=1时，这一组扩充的Fibonacci数就变成一般的Fibonacci数，现在请编写一个函数，接收一个n值，不用数组与递归的方法算出下面的结果:
F(0).F(1) + F(1).F(n-1)+...+F(i).F(n-1)+...+F(n-1).F(1)+F(n).F(0)

说明:与许多求某个式子的和的程序一样，也不能马上下手编写程序。因为数学家用的式子与编写程序的式子不同, 数学家讲求式子要能表达出原意, 而编程的式子则要求好算, 不仅如此,还要运算得快。 如果用上面的式子, 为了要用到F(0)与F(n),可能要用一个数组把F(0), F(1), F(n)算出来后保存起来, 再两两相乘、相加。这种方法固然不错, 但当n比较大时,内存的要求就大了,所以限定不能用数组.

因此, 这里的提示是把式子换个面目,看有没有办法实现不用递归来算 Fibonacci数的程序。

## 2.16 连续整数的固定和(GivenSum)

编写一个程序, 读入一个正整数, 把所有那些连续的和为给定的正整数的正整数找出来。例如,如果输入27, 发现2~7、8~10、13与14的和是27, 这就是解答:如果输入的是10000, 应该有18~142、297~1328、388~412、1998~2002这4组。注意, 不见得一定会有答案,譬如说4、16就无解; 另外, 排除只有一个数的情况, 否则每一个输入就都至少有一个答案, 就是它自己.

说明: 任何人看到这个题目都会马上想到一个办法, 把所有的和算出来, 与输入比较。曾经看到过如下的一个解法, 如下程序所示

```
def bad_given_sum(n):
    result = []
    mid = int(n / 2)
    for i in range(1, mid + 1):
        s = i
        for j in range(i + 1, mid + 1 + 1):
            s += j
            if s == n:
                result.append((i, j))
    return result
```

它的做法是先固定一个i, sum变量, 接着令j 从i + 1起变化, 每次都把j的值加到sum 中，
因此sum中的值就是i, i + 1,...,这些连续整数的和. 因此令i 从1 编导n / 2(n是给定的数), 而j从计1变到n / 2 + 1, 如果有一个和与n相同, 就显示i与j,表示n的值是i到j这一串连续的正整数的和。为什么i要从1到n / 2? 很简单, 如果i是n / 2,下一个数就是n / 2 + 1, 于是这两个(连续的)数的和n / 2 + (n / 2 + 1) = n + 1就大于n, 所以i最多只能到n / 2; 同理可以说明j 不可以大过n / 2 + 1

这个程序当然是对的, 但运行太慢了! 用10000作为输入, 它一共执行了311.71秒, 也就是5分钟多: 但事实上, 这个题目可以在不到一秒之内得出答案, 而且当输入1000000(100万)时,也不过用178.12秒(3分钟)左右而已,相比之下bad_given_sum的效率实在太低了。(本书写于1988年，那时候计算机性能还不够好)

问题出在什么地方? 加法次数太多了。在上面的程序中, i与j的关系永远满足1 <= i <= n / 2, i + 1 <= j <= n / 2 + 1, i < j, 每一组i与j都会做一次加法,所以就一共做了大约n ^ 2 / 8个加法(这是个近似值); 当n = 10000时,就大约是1250万个。

不过, 一个好程序员应该研究是否有更好的方法存在, 事实上就有一个, 大约需要2n
个加法就足够了, 能想得出来吗? 下面是几点有用的提示:

1. 如果在求和时是用i + (i + 1) + … + j表示, 那么 i <= n / 2; 这是上面提过的。
2. 如果某个和i + (i + 1) + … + j比给定的值大, 那么把和变小, 但仍然维持是一串连
续整数的和时, 拿掉j变成i + (i + 1) + … + (j - 1),不如拿掉i变成(i + 1) + … + j。为什么? 因为j比i大, 拿掉j, 和就下降太快了, 不如拿掉i, 再慢慢降低(能用数学来证明吗?)
3. 如果和i + (i + 1) + … + j比给定值小, 加上j + 1变成的i + … + j + j + 1; 道理同前。

有了这几点, 编程应该不会是件难事了。

解答见[given_sum.py](https://github.com/dengshilong/C100Problem/blob/master/chapter2/given_sum.py)

# chapter3

## 3.1 列出所有子集(DIRECT)

编写一个程序,列出{1, 2, 3, … , n}这个集合的所有子集, 包括空集合.

说明: 列出一个集合的所有子集有很多做法,题目中并没有要求依某个特定的次序来排列,
因此是不难做出来的。 因为集合中一共有n个元素,所以总共就会有2 ^ n 个子集; 例如{1, 2, 3} 有如下子集: {} {1} {2} {3} {1, 2} {1, 3} {2, 3} {1, 2, 3}

解答见[direct.py](https://github.com/dengshilong/C100Problem/blob/master/chapter3/direct.py)

## 3.5 产生所有排列字典顺序(RecursionPermutation)
若编写一个程序,用字典顺序列出n个元素的所有排列(Permutation)


说明:
下面是一个n = 4，用字典顺序列出来的所有排列，一共为4! = 24个。

1234 2134 3124 4123

1243 2143 3142 4132

1324 2314 3214 4213

1342 2341 3241 4231

1423 2413 3412 4312

1432 2431 3421 4321

字典顺序的先后是这样定义的, 如果a(1)a(2)…a(n)与b(1)b(2)…b(n)是n个元素的两个排列
于是有a(1)=b(1), a(2)=b(2),...a(i)=b(i),但a(i+1)<b(i+1), 就是说a(1)a(2)a(n)。在b(1)b(2)b(n)的前面,或者说前者较"小"; 注意,自i+2个之后的各个元素是没有影响的。其实, 这就是用来决定字符串大小的方式。举例而言, 2314与2341,前两个元素相同,但第三个为1<4,所以2314在前, 2341在后; 同理, 1234与4321相比, 1234在前,4321在后。

如何产生字典顺序的排列呢? 据Hall与 Knuth的考证, 200年(1812年)前Fischer与Kruse在他们的一本书中就已经提过这样的方法了。从1234…n开始,首先从右到左出第一对满足a(i)<a(i+1)n的a(i)与a(i+1),于是从a(i+1)起在它右边的就是越来越小的:有了a(i)之后再一次地从右到左查一次, 找出第一个满足a(i)< a(j)的a(j)。接着把a(i)到a(j)的各个元素反过来排, 就是字典顺序的下一个了。下面来看看如何找出153642的下一个:从右到左第一组满足a(i) < a(i+1)的是3与6,所以a(i),就是3。接着从右到左去找第一个a(j),使得a(i) < a(j),则是3 < 4; 把a(i)和a(j)换下位置，最后把a(i+1)与a(n)之间的元素反过来排,因此得到154236,这就是结果。

看另一个递归的做法。看上面4! = 24个排列的第一列，它们的第一个元素都是1，第一列的最后一个是以1开头，用字典顺序排出来的最后，自然是1432.事实上，如果是n个元素的排列，以1开头的最后一个应该是1n(n-1)…432。下一列是2开头，把n(n-1)…432中最小的一个与第一个互换，也就是把倒数第一个与第一个互换，得到2n(n-1)..431，但这不是1n(n-1)…432的下一个，但是如果把后面的n - 1个元素反过来，就会得到2134…(n-1)n，是正确的顺序，于是进入第二列。

第二列的最后一个应该是2n(n-1)…431,把 n(n-1)…431中最小的与第一个互换，但因为1已经出现过了，所以把倒数第二个元素(自然是3)与第一个互换，得到3n(n-1)…421，再把后面的n - 1个元素反过来，得到3124…(n-1)n，就得到第三列的第一个。

第三列的最后一个是3n(n-1)…421, 把n(n-1)…421中最小的与第一个互换，但因为1，2已经出现过了，所以把倒数第3个元素(自然是4)与第一个互换，得到4n(n-1)…321，再将后面n - 1个反过来排，得到4123…(n - 1)n，正好是第4列的第一个元素。

于是我们可以得到一个递归的做法，从1234…n起，用一个递归的程序

1. i = n
2. 对后面n - 1个进行排列(递归的)
3. 把第i位与第1位互换
4. i减去1
5. 把后面的n - 1位反过来排
6. 回到第2步

当i到第一位时程序结束。

解答见[recursion_permutation.py](https://github.com/dengshilong/C100Problem/blob/master/chapter3/recursion_permutation.py)


## 3.8 整数的所有不同分割数目(IntegerPartition)
所谓的整数的分割(Partition of an Integer), 指的就是把一个正整数写成若干个正整数的和，但这里只计较有多少种分割方式，而不计较它的内容。例如，4=3+1,2+2,2+1+1,1+1+1+1+1, 再加上自己，就一共有5种分割方式。编写一个程序，输入一个正整数，输出它有多少种分割方式。

说明: 以下是几点重要的提示

1. 要把n进行分割，其实不完全只针对n, 还要看分割中最大的值是什么。例如，要把10进行分割，若在分割中最大的值是6，即10=6+..., 那么"..."的部分充其量的值是4而已，不仅如此，和还须等于4；因此，如果知道"...", 即4有多少种分割方式，也正是在分割10时，最大值为6的分割方式！
2. 应该分析一下n这个输入值，与在分割中的极大值(如1.中的6)之间有什么联系，找出来，问题就解决了。
3. 不要忘了，递归是非常有效的武器

解答见[integer_partition.py](https://github.com/dengshilong/C100Problem/blob/master/chapter3/integer_partition.py)

## 3.9 整数的分割方式(IntegerPartitionII)

对于一个正整数n而言，它的一个分割(Partition),就是把n写成若干个正整数的和，但不计较书写的顺序。编写一个程序，输入n，把n的所有分割显示出来。
说明: 如果n=7, 那么有如下的分割.
> 7
> 
> 6 1
> 
> 5 2
> 
> 5 1 1
> 
> 4 3
> 
> 4 2 1
> 
> 4 1 1 1
>
> 3 3 1
> 
> 3 2 2
> 
> 3 2 1 1
>
> 3 1 1 1 1 
>
> 2 2 2 1
>
> 2 2 1 1 1 
>
> 2 1 1 1 1 1 
> 
> 1 1 1 1 1 1 1

一共有15个，仔细观察在各个输出中前后两者的差异，并且自己做一做其他的结果(比如n=5时有7个，n = 6时有11个等),就不难写出程序了。

解答见[integer_partition_method.py](https://github.com/dengshilong/C100Problem/blob/master/chapter3/integer_partition_method.py)


## 4.1 寻找脚码(IndexSearch)
已知一个整数数组x[], 其中的元素彼此都不相同,而且也已经从小到大排列好,请用
比较大小、相等的方式编写一个程序, 找出给定的数组中是否存在一个元素满足x[i] = i的关
系。举例而言, 如果x[]={-2,-1,3,7,8}, x[3] = 3, 因此 3 就是答案, 因为编程语言中数组是从0开始的，所以最终是检测是否存在一个元素满足x[i] = i + 1.

说明: 用笨方法, 一个循环就可以找出答案, 如下程序所示

```
def bad_index_search(x):
    index = -1
    for i in range(0, len(x)):
        if x[i] == i + 1:
            index = i + 1
            break
    return index

if __name__ == "__main__":
    x = [-2, -1, 3, 7, 8]
    print(bad_index_search(x))
```

这个程序在最坏的情况下, for一共绕了n圈, 作了n次比较, 但却没有用到x[]的元
素已经排列好的条件. 事实上, 如果输入有n个元素, 应该可以写出与log(n)次成正比的比较的程序,关键是x[]的元素是排好顺序的。

解答见[index_search.py](https://github.com/dengshilong/C100Problem/blob/master/chapter4/index_search.py)

## 4.7 3个数组的共同元素(SearchThree)
有3个数组x, y 与 z, 各有x、y 与 z 个元素,而且三者都已经从小到大依序排列。编写一个程序, 找出值最小的共同元素(也就是同时在3个数组中出现, 并且值最小的元素);但若没有共同元素, 请显示合适的信息。

说明: 通常寻找数据的工作都是给了一个数据, 看看在某个数组中有没有它, 但是这个问题却是另一个目的, 要找出一个共同的元素。 其实在实际应用中这种类型是屡见不鲜的。例如, 警察知道犯人是合北市人, 有大学学历, 有窃盗前科, 因此就可能从台北市得到这个台北人的档案, 从教育部取得历年大学毕业生的档案, 再从警察局取得有窃盗前科的人的档案, 如果这些档案已经依人名从小到大排好了, 那么找出嫌疑人的工作就与本题差不多所不同的是: 第一, 只要找出第一个, 而警察局可能要找出所有的; 第二, 用数组处理,所以得知该元素个数,而警察局收到的是档案, 也许不知道各个档案有多少笔数据而已。因为不知道要找的是什么, 所以二分查找法没有多大用处, 要另外想办法来解题, 据我所知,最多用3min(x, y, z)次比较就可以决定答案, 更重要的是程序将不超过10行, 所以要往深处思考。



## 4.9 查找矩阵(MatrixSearch)
已知一个n列n行的矩阵M,它的元素满足一个很特殊的性质, 即任一元素M[i][j]都小
于在它右边与下方的元素(如果存在的话), 换言之,M[i][j] < M[i][j+1]且M[i][j] < M[i+1][j]. 现在有一个值K, 编写一个程序, 检查矩阵M中是否有K。

说明: 这个矩阵有了一种很特殊的结构, 换言之, 每一列与每一行都从小到大排列, 所以做寻找的工作时就可以通过这个特殊的顺序来编写程序。注意, 虽然有n ^ 2个元素, 但理论上可以证明, 在最坏的情况下, 2n - 1就可以决定K在不在M中; 关键所在, 就是如何模仿二分查找法的技巧在一次比较之后就尽可能去掉多余的元素.

解答见[matrix_search.py](https://github.com/dengshilong/C100Problem/blob/master/chapter4/matrix_search.py)

## 7.2 三色旗问题(ThreeFlag)
假设有一个数组, 它有n个元素,每一个不外乎是红、白、蓝3种颜色之一的代号, 就说是R, W, B好了。这些元素在数组中并没有依同样颜色的元素排在一起的方式来排列, 请写一个程序把这些元素排成所有蓝色在前, 然后是白色, 最后是红色的排列方式, 不过在写程序时要满足下面的条件

1. 不能用到额外的内存,换句话说,只能在数组之内用互换的方式完成。
2. 互换两个元素的动作要越少越好
3. 对于每一个元素而言,测试它是红, 白, 还是蓝的工作, 每种颜色最多只能做一次测试

在这个限制之下,请编写一个最快的程序

说明: 有些人很自然地会想到把蓝色当成1、白色当成2、红色当成3, 然后用排大小的程序把次序排出来,自然地蓝色在前, 白色居中, 红色最后了; 完全正确, 不过却违背了规定。也就是说, 互换两个元素的动作是不是太多了呢? 对每一个元素测试它的颜色的行为是否违反了要求呢? 对前者而言,不同的排序方法会有不同数目的互换动作。比如说,如果用选择法, 每次找到计i+1 ~ n中最小的值, 与第i个元素互换, 那么排序的动作只不过用了n-1次互换。但是对第三个限制而言, 就很难保证对每一个元素、每一种颜色都最多只测试次了

第三个条件需要仔细地说明, x[i]表示第i个元素。第三个条件是说, x[i] == R, x[i] == W, x[i] == B 这3个比较的任何一个都最多只能做一次。举个例子, 如果在决定观应该放在什么地方时,上述3个比较都各做一次,是正确的。任取两个或任取一个各做一次,也是正确的。但x[i] == R、x[i] == W、x[i] == R就是错的了, 因为对R的测试做了两次。

其实这个题目并不难, 把数组从头到尾查一次就可以做出结果, 那3个繁琐的条件, 不过是防止去用排序或“不够快”的方法来解题而已。

解答见[three_flag.py](https://github.com/dengshilong/C100Problem/blob/master/chapter7/three_flag.py)


## 7.12 产生匹配括号的字符串(GenerateParenthesis)
请写一个程序, 输入一个正整数的值, 然后列出所有由n个左括号与n个右括号正确成的字符串; 当然, 正确的左, 右括号一定个数一样多, 所以输入的值要是个偶数

说明: 所谓由括号正确地组成的字符串, 指的是如果有一个左括号, 那么在它的右边就一定有一个与它相匹配的右括号。例如,()()、(()),就是仅有的两个有4个符号的, 由括号正确地组成的字符串:()()()、()(())、(())()、(()())、((()))则是5个有6个符号, 由括号正确地组成的字符串。正因为有一个左(或右)括号就一定有相对应的右(或左)括号, 左、右括号成双出现, 因此输入就一定要是偶数, 奇数是不可能的。当输入n之后, 在字符串中左、右括号的个数就各是n/2个。

如何产生这样的字符串呢？下面就是一个有用的想法：如果在产生的过程中已经产生了若干左、右括号，为了要把产生的行为完成，还欠R个左括号、L个右括号，那么有没有办法找出产生下一个括号时L与R的关系呢？记住，递归是一个不容忽视的利器。

解答见[generate_parenthesis.py](https://github.com/dengshilong/C100Problem/blob/master/chapter7/generate_parenthesis.py)


## 9.6 最大连续元素和( MaximuConsecutiveSum)
已知数组x[]储存了一组整数, 请写一个程序, 找出在数组中连续元素的和中最大的一个。举例而言, 如果有数组[1, 2, -6, 3, -2, 4, -1, 3, 2, -4], 那么连续的元素的和有1 + 2 = 3, 1 + 2 + (-6) = 3, 2 + (-6) = 4, ..., 但值最大的就是3 + (-2) + 4 +(-1) + 3 + 2这一段, 值为9. 规定: 和为负值时就定成0, 所以结果永远不为负。这个题目通常叫做最大连续元素和( Maximum Consecutive Sum)问题
说明: 这个问题有个很简单的解法, 但效率很低, 一般采用效率很高的方法的程序比使用不
好的方法的要长。一般人看到这个问题的自然反应就是用两个循环, 如程序所示。

```
def bad_method(x):
    max_sum = 0
    for i in range(len(x)):
        s = 0
        for j in range(i, 0, -1):
            s += x[j]
            if s > max_sum:
                max_sum = s
    return max_sum
```

想法是很简单的, 当固定在某个x[i]之后, 把x[i], x[i-1] + x[i], x[i-2] + x[i-1] + x[i], ... x[0] + x[1] + ... x[i]求出来, 一边算, 一边找出极大值, 这就是上面片段所隐含的意义。但是, 当处理到i时要查i个元素, 所以要把n个数都处理完,就要查1 + 2 + 3 + … + i + ... + n = n(n+1)2、与n ** 2成正比的元素了。如果仔细看就会发现做了很多重复的工作, 为什么? 当i是2时,算了x[2], x[1] + x[2], x[0] + x[1] + x[2], 但当i进到下一个位置变成3时, 又算x[3], x[2] + x[3], x[1] + x[2] + x[3], x[O] + x[1] + x[2] + x[3], 于是x[1] + x[2] 与 x[O] + x[1] + x[2]不都是重复算了吗? 因此, 程序如果能够避免这些重复的部分, 就一定会非常快。

解答见[maximum_consecutive_sum.py](https://github.com/dengshilong/C100Problem/blob/master/chapter9/maximum_consecutive_sum.py)






