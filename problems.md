# chapter1
## 1.1 最长平台问题(Pleateau)
已知一个已经从小到大排序的数组，这个数组中的一个平台(plateau) 就是连续的一串相同的元素，并且这一串元素不能再延伸。

例如，在1，2，2，3，3，3，4，5，5，6中1，2.2，3.3.3，4，5.5，6都是平台。试编写一个程序，接受一个数组，把这个数组中最长的平台找出来。

在上面的例子中，3.3.3就是该数组的最长平台。

说明:
这个程序十分简单，但是要编写号却不容易，因此在编写程序时应该考虑下面几点：

1. 使用的变量越少越好
2. 能否只把数组的元素每一个只查一次就得到结果？
3. 程序语句越少越好。

这个问题曾经困扰过 David Gries这位知名的技术机科学家。本题与解答取自David Gries编写的有光程序设计的专著。

解答见[Pleateau.java](https://github.com/dengshilong/C100Problem/blob/master/src/chapter1/Pleateau.java)

## 1.2 支配值数目(GTCount)
已知f[]与g[]两个整数数组，元素已经从小到大排列，请写一个程序，算出f[]中比g[]元素大的对数。换句话说，f[0]比g[]中多少个元素大，f[1]比g[]中多少元素大等，这些值的总和就是要求的答案。

例如，如果f[]中有1，3，5，7，9，而g[]中有2，3，4，7，8，比g[0]大的有f[1]~f[4], 比g[1]大的有f[2]~f[4]，比g[2]大的有f[2]~f[4]，比g[3]大的有f[4]，比g[4]大的有f[4]，因此答案是4 + 3 + 3 + 1 + 1 = 12

说明: 与问题1.1一样，需要特别注意数组f[]与g[]已经排序。如果问题1.1能够做出完美的解答，那么本题也不难，相似的方法就可以得到高效率的程序。

利用数组已经排好序的这个特性，可以写出高效的程序. 解答见[GTCount.java](https://github.com/dengshilong/C100Problem/blob/master/src/chapter1/GTCount.java)


## 1.3 等值数目(EQCount)
已知两个整数数组f[]与g[]，它们的元素都已经从小到大排列好，而且两个数组中的元素都各不相同。例如，f[]中有1,3,4,7,9,而g[]中有3,5,7,8,10。试编写程序算出这两个数组之间有多少组相同的元素。

就上例而言，f[2]和g[1]为3是一组​; f[3]与g[2]为7是第二组

说明: 建议不要使用下面的方法来编程

1. 固定f[i]
2. 对于f[i]而言，检查g[]中是否有与f[i]相同的元素
3. 处理下一个f[i], 即f[i + 1]

因为f[]与g[]都已经从小到大排列好，所以应该活用这一个很强的特性。一个好的程序员绝对不应用上面的笨拙方法来编写程序, 这样会做太多无意义的事。为什么呢？因为g[]的元素都相异，对于f[i]而言，最多只会找出一个与它相同的元素，最坏的情况时把g[]全部查完才找出相同元素(如果采用上面的方法), 如果g[]中有n个元素，需要查n次; 但是若f[]中也有n个元素，那么需要把g[]查n遍，一共作n ** 2(Python的记法，即n的2次方)次比较才能找出结果。

试着找出一种方法，把f[]与g[]各查一次就可以得到答案(记住, 活用f[]与g[]已经从小到大排列的特性).

做完这一题后，建议继续作下一题。

依然是利用已经排好序的这个特性。解答见[EQCount.java](https://github.com/dengshilong/C100Problem/blob/master/src/chapter1/EQCount.java)

## 1.4 两数组最短距离(MinDist)
已知两个元素从小到大排列的数组x[]与y[],请编写一个程序算出两个数组元素彼此之间差的绝对值最小的一个树，此值称为数组的距离。

说明： 如果x[i]与y[i]是两个元素，那么 |x[i] - y[i]| 就是这两个元素之间的距离，所有这些距离的最小值，称为数组的距离。比如说x[]有1，3，5，7，9， y[]有2，6，8，那么最短距离就是1，因为x[0]与y[0]、 x[1]与y[0]、x[2]与y[1]、x[3]与y[1]、还有x[4]与y[2]的距离都是1。

注意，如果x[]与y[]各有m与n个元素，那么元素之间的距离就一共有m * n个; 事实上往往用不着这么多个值，应该活用x[]与y[]已经排列好的特性，不要把所有的距离都算出来。

依然是利用数组已经排好序的特性。解答见[MinDist.java](https://github.com/dengshilong/C100Problem/blob/master/src/chapter1/MinDist.java)

## 1.5 等值首尾和(HeadTail)
假设有一个数组x[ ], 它有n个元素，每一个都大于零，称x[0] + x[1] + … + x[i]为前置和(Prefix Sum),而 x[j] + x[j + 1] + … + x[n - 1]为后置和(Suffix Sum)。试编写一个程序，求出x[ ] 中有多少组相同的前置和与后置和。

说明: 如果x[ ] 的元素是3，6，2，1，4，5，2，则x[ ]的前置和有一下7个，即3，9，11，12，16，21，23；后置和则是2，7，11，12，14，20，23；于是11，12，与23这3对就是值相同的前置和与后置和，因为：

> 11 = 3 + 6 + 2(前置和) = 2 + 5 + 4 (后置和)
>
>12 = 3 + 6 + 2 + 1(前置和) = 2 + 5 + 4 + 1 (后置和)

因为23是整个数组元素的和，因此前置和与后置和一定相同。

当然，也可以用上面的方法把前置和与后置和都算出来(两者都是从小到大的递增序列, 为什么?), 再进行比较, 但建议不要使用这种方法, 因为它需要额外的内存。

可以用变量prefix来表示前置和，用suffix来表示后置和，用i表示前置和累加元素的位置，i从前往后加，用j表示后置和累加元素的位置, j从后往前加。当prefix > suffix时，累加后置和，也就是j向前走；当prefix < suffix时，累加前置和，也就是i往后走；当prefix == suffix时，同时累加前置和与后置和，也就是i往后走，j往前走. 解答见[HeadTail.java](https://github.com/dengshilong/C100Problem/blob/master/src/chapter1/HeadTail.java)

# chapter2

## 2.3 求质数(PrimeOne)
试编写一个程序，找出前 N(如200)个质数。如果没有进一步要求，这不是难题。但再次希望从所知的、使用除法的方法中，用最快的办法来编写程序.

说明: 可能最先想到的办法，就是让某个变量 i 从 2 变到 N，然后检查它是不是质数，如果是就显示出来，如果不是，就检查下一个。这是正确的做法，但却没有注意到一个小细节，因而使程序运行速度变慢。当然，2是质数，但所有 2 的倍数都不是质数，如果令 i 从 2 变到 N, 不就很冤枉的测试了 4,6,8,10,...这些数? 所以第一点提示是测试 2,3,5,7,...,N, 即 2 与所有奇数就足够了。同理，3 是质数，但 6,9,12,...这些3的倍数却不是，因此，如果能把 2 与 3的倍数都跳过去而不测试，任意连续的 6个数中，就只会测试两个而已。以6n,6n + 1,6n + 2, 6n + 3, 6n + 4, 6n + 5为例，6n, 6n + 2, 6n + 4是偶数, 6n + 3是3的倍数, 所以如果把 2 与 3 的倍数都不理会，要测试的数就只留下6n + 1与6n + 5而已，因而工作量之时前述想法的2 / 6= 1/3, 应该用这个办法去编写程序。

假如i 是如上述的一个数(不是2 与 3 的倍数), 如何测试 i 是个质数呢? 按照定义 i 如果是质数, 也就只有 1 与 i 可以除尽自己，所以可以用2, 3, 4, 5, 6, ..., i - 1去除 i, 如果都除不尽(余数不是0), i 就是质数。观点也对，但却与上一点一样地笨拙。当 i > 2 时，有哪一个数 i 可以被 i - 1除尽的? 没有, 为什么? 如果 i 不是质数, 那么 i = a * b, 此地 a 与 b 既不是 i 又不是 1; 正因为 a > 1, a 至少是2， 因此 b 最多是 i / 2而已，去除 i 的数用不着是 2,3,4,...,i - 1, 而用 2,3,4,..., i / 2就可以了。 不但如此，因为 i = a * b, a 与 b 不能大于 i 的平方根, 为什么呢? 如果a > i 的平方根, b > i 的平方根, 于是a * b > i, 因此就都不能整除i了。如果 i 不是质数, 它的最大因子就是 i 的平方根； 换言之，用2,3,4,5,...,i的平方根去除 i 就行了。

但是, 用2,3,4,5,...,i的平方根去除i也是个浪费。就像前一段所说的，2除不尽，2的倍数也除不尽；同理 3 除不尽，3 的倍数也除不尽......最理想的方法就是用质数去除 i, 因为在前一段的提示， i 不是 2 与 3的倍数，所以就用5, 7, 11, 13, 17, 19,...这些比i的平方根小的质数去除 i 即可。

但问题是这些质数从he
## 2.7 数组自乘递归解(RecursionPower)
如果n与m是正整数, 那么m ** n 就是把m连乘n次, 这是一个效率很低的方法，请写一个计算效率高的程序 ，并且分析城中一共用了多少个乘法，应该以n - 1个乘法作为设计准则。

说明: 这是一个典型的递归设计题目，应该注意一下几点

1. 试用分而治之(Divide and Conquere)的策略
2. 注意到x ** 4可以用x ** 2自乘的关系，由此可以大量地降低乘法数目
3. 连乘n次要n - 1个乘法，能做到只要2logn个乘法吗？

# chapter3
## 3.8 整数的所有不同分割数目(IntPartition)
所谓的整数的分割(Partition of an Integer), 指的就是把一个正整数写成若干个正整数的和，但这里只计较有多少种分割方式，而不计较它的内容。例如，4=3+1,2+2,2+1+1,1+1+1+1+1, 再加上自己，就一共有5种分割方式。编写一个程序，输入一个正整数，输出它有多少种分割方式。

说明: 一下是几点重要的提示

1. 要把n进行分割，其实不完全只针对n, 还要看分割中最大的值是什么。例如，要把10进行分割，若在分割中最大的值是6，即10=6+..., 那么"..."的部分充其量的值是4而已，不仅如此，和还须等于4；因此，如果知道"...", 即4有多少种分割方式，也正是在分割10时，最大值为6的分割方式！
2. 应该分析一下n这个输入值，与在分割中的极大值(如1.中的6)之间有什么联系，找出来，问题就解决了。
3. 不要忘了，递归是非常有效的武器

## 3.9 整数的分割方式(IntPartitionII)

对于一个正整数n而言，它的一个分割(Partition),就是把n写成若干个正整数的和，但不计较书写的顺序。编写一个程序，输入n，把n的所有分割显示出来。
说明: 如果n=7, 那么有如下的分割.
> 7
> 
> 6 1
> 
> 5 2
> 
> 5 1 1
> 
> 4 3
> 
> 4 2 1
> 
> 4 1 1 1
> 
> 3 2 2
> 
> 3 2 1 1
> 
> 3 1 1 1 1 
> 
> 2 1 1 1 1 1 
> 
> 1 1 1 1 1 1 1

一共有12个，仔细观察在各个输出中前后两者的差异，并且自己做一做其他的结果(比如n=5时有7个，n = 6时有11个等),就不难写出程序了。
