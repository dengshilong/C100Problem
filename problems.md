# chapter1
## 1.1 最长平台问题(Pleateau)
已知一个已经从小到大排序的数组，这个数组中的一个平台(plateau) 就是连续的一串相同的元素，并且这一串元素不能再延伸。

例如，在1，2，2，3，3，3，4，5，5，6中1，2.2，3.3.3，4，5.5，6都是平台。试编写一个程序，接受一个数组，把这个数组中最长的平台找出来。

在上面的例子中，3.3.3就是该数组的最长平台。

说明:
这个程序十分简单，但是要编写号却不容易，因此在编写程序时应该考虑下面几点：

1. 使用的变量越少越好
2. 能否只把数组的元素每一个只查一次就得到结果？
3. 程序语句越少越好。

这个问题曾经困扰过 David Gries这位知名的技术机科学家。本题与解答取自David Gries编写的有光程序设计的专著。

解答见[pleateau.py](https://github.com/dengshilong/C100Problem/blob/master/chapter1/pleateau.py)

## 1.2 支配值数目(GTCount)
已知f[]与g[]两个整数数组，元素已经从小到大排列，请写一个程序，算出f[]中比g[]元素大的对数。换句话说，f[0]比g[]中多少个元素大，f[1]比g[]中多少元素大等，这些值的总和就是要求的答案。

例如，如果f[]中有1，3，5，7，9，而g[]中有2，3，4，7，8，比g[0]大的有f[1]~f[4], 比g[1]大的有f[2]~f[4]，比g[2]大的有f[2]~f[4]，比g[3]大的有f[4]，比g[4]大的有f[4]，因此答案是4 + 3 + 3 + 1 + 1 = 12

说明: 与问题1.1一样，需要特别注意数组f[]与g[]已经排序。如果问题1.1能够做出完美的解答，那么本题也不难，相似的方法就可以得到高效率的程序。

利用数组已经排好序的这个特性，可以写出高效的程序. 解答见[gt_count.py](https://github.com/dengshilong/C100Problem/blob/master/chapter1/gt_count.py)


## 1.3 等值数目(EQCount)
已知两个整数数组f[]与g[]，它们的元素都已经从小到大排列好，而且两个数组中的元素都各不相同。例如，f[]中有1,3,4,7,9,而g[]中有3,5,7,8,10。试编写程序算出这两个数组之间有多少组相同的元素。

就上例而言，f[2]和g[1]为3是一组​; f[3]与g[2]为7是第二组

说明: 建议不要使用下面的方法来编程

1. 固定f[i]
2. 对于f[i]而言，检查g[]中是否有与f[i]相同的元素
3. 处理下一个f[i], 即f[i + 1]

因为f[]与g[]都已经从小到大排列好，所以应该活用这一个很强的特性。一个好的程序员绝对不应用上面的笨拙方法来编写程序, 这样会做太多无意义的事。为什么呢？因为g[]的元素都相异，对于f[i]而言，最多只会找出一个与它相同的元素，最坏的情况时把g[]全部查完才找出相同元素(如果采用上面的方法), 如果g[]中有n个元素，需要查n次; 但是若f[]中也有n个元素，那么需要把g[]查n遍，一共作n ** 2(Python的记法，即n的2次方)次比较才能找出结果。

试着找出一种方法，把f[]与g[]各查一次就可以得到答案(记住, 活用f[]与g[]已经从小到大排列的特性).

做完这一题后，建议继续作下一题。

依然是利用已经排好序的这个特性。解答见[eq_count.py](https://github.com/dengshilong/C100Problem/blob/master/chapter1/eq_count.py)

## 1.4 两数组最短距离(MinDist)
已知两个元素从小到大排列的数组x[]与y[],请编写一个程序算出两个数组元素彼此之间差的绝对值最小的一个数，此值称为数组的距离。

说明： 如果x[i]与y[i]是两个元素，那么 |x[i] - y[i]| 就是这两个元素之间的距离，所有这些距离的最小值，称为数组的距离。比如说x[]有1，3，5，7，9， y[]有2，6，8，那么最短距离就是1，因为x[0]与y[0]、 x[1]与y[0]、x[2]与y[1]、x[3]与y[1]、还有x[4]与y[2]的距离都是1。

注意，如果x[]与y[]各有m与n个元素，那么元素之间的距离就一共有m * n个; 事实上往往用不着这么多个值，应该活用x[]与y[]已经排列好的特性，不要把所有的距离都算出来。

依然是利用数组已经排好序的特性。解答见[min_dist.py](https://github.com/dengshilong/C100Problem/blob/master/chapter1/min_dist.py)

## 1.5 等值首尾和(HeadTail)
假设有一个数组x[ ], 它有n个元素，每一个都大于零，称x[0] + x[1] + … + x[i]为前置和(Prefix Sum),而 x[j] + x[j + 1] + … + x[n - 1]为后置和(Suffix Sum)。试编写一个程序，求出x[ ] 中有多少组相同的前置和与后置和。

说明: 如果x[ ] 的元素是3，6，2，1，4，5，2，则x[ ]的前置和有一下7个，即3，9，11，12，16，21，23；后置和则是2，7，11，12，14，20，23；于是11，12，与23这3对就是值相同的前置和与后置和，因为：

> 11 = 3 + 6 + 2(前置和) = 2 + 5 + 4 (后置和)
>
>12 = 3 + 6 + 2 + 1(前置和) = 2 + 5 + 4 + 1 (后置和)

因为23是整个数组元素的和，因此前置和与后置和一定相同。

当然，也可以用上面的方法把前置和与后置和都算出来(两者都是从小到大的递增序列, 为什么?), 再进行比较, 但建议不要使用这种方法, 因为它需要额外的内存。

可以用变量prefix来表示前置和，用suffix来表示后置和，用i表示前置和累加元素的位置，i从前往后加，用j表示后置和累加元素的位置, j从后往前加。当prefix > suffix时，累加后置和，也就是j向前走；当prefix < suffix时，累加前置和，也就是i往后走；当prefix == suffix时，同时累加前置和与后置和，也就是i往后走，j往前走. 解答见[head_tail.py](https://github.com/dengshilong/C100Problem/blob/master/chapter1/head_tail.py)

# chapter2

## 2.3 求质数(PrimeOne)
试编写一个程序，找出前 N(如200)个质数。如果没有进一步要求，这不是难题。但再次希望从所知的、使用除法的方法中，用最快的办法来编写程序.

说明: 可能最先想到的办法，就是让某个变量 i 从 2 变到 N，然后检查它是不是质数，如果是就显示出来，如果不是，就检查下一个。这是正确的做法，但却没有注意到一个小细节，因而使程序运行速度变慢。当然，2是质数，但所有 2 的倍数都不是质数，如果令 i 从 2 变到 N, 不就很冤枉的测试了 4,6,8,10,...这些数? 所以第一点提示是测试 2,3,5,7,...,N, 即 2 与所有奇数就足够了。同理，3 是质数，但 6,9,12,...这些3的倍数却不是，因此，如果能把 2 与 3的倍数都跳过去而不测试，任意连续的 6个数中，就只会测试两个而已。以6n,6n + 1,6n + 2, 6n + 3, 6n + 4, 6n + 5为例，6n, 6n + 2, 6n + 4是偶数, 6n + 3是3的倍数, 所以如果把 2 与 3 的倍数都不理会，要测试的数就只留下6n + 1与6n + 5而已，因而工作量之时前述想法的2 / 6 = 1/3, 应该用这个办法去编写程序。

假如i 是如上述的一个数(不是2 与 3 的倍数), 如何测试 i 是个质数呢? 按照定义 i 如果是质数, 也就只有 1 与 i 可以除尽自己，所以可以用2, 3, 4, 5, 6, ..., i - 1去除 i, 如果都除不尽(余数不是0), i 就是质数。观点也对，但却与上一点一样地笨拙。当 i > 2 时，有哪一个数 i 可以被 i - 1除尽的? 没有, 为什么? 如果 i 不是质数, 那么 i = a * b, 此地 a 与 b 既不是 i 又不是 1; 正因为 a > 1, a 至少是2， 因此 b 最多是 i / 2而已，去除 i 的数用不着是 2,3,4,...,i - 1, 而用 2,3,4,..., i / 2就可以了。 不但如此，因为 i = a * b, a 与 b 不能大于sqrt(i)(即i的平凡根), 为什么呢? 如果a > i 的平方根, b > i 的平方根, 于是a * b > i, 因此就都不能整除i了。如果 i 不是质数, 它的最大因子就是sqrt(i)； 换言之，用2,3,4,5,...,sqrt(i)去除 i 就行了。

但是, 用2,3,4,5,...,sqrt(i)去除i也是个浪费。就像前一段所说的，2除不尽，2的倍数也除不尽；同理 3 除不尽，3 的倍数也除不尽......最理想的方法就是用质数去除 i, 因为在前一段的提示， i 不是 2 与 3的倍数，所以就用5, 7, 11, 13, 17, 19,...这些比sqrt(i)小的质数去除 i 即可。

但问题是这些质数从何而来? 这比较简单，可以准备一个数组prime[], 用于存放找出来的质数, 一开始它应该有2 、3与5。于是当 i = 5,7,11,13,17,19,23,25,29,...这些不是 2 与 3 的倍数时，就用prime[]中小于 sqrt(i)的数去除 i 即可，如果都除不尽，i 就是质数，把它放入prime[]中，因此prime[]中的质数就会越来越多，直到满足所要的个数为止。

不妨用这段说明来编写程序，不过应注意下面几点:

1. 不要处理2 与 3 的倍数(见第一段)
2. 用质数去除(见第二、三段).
3. 用i的平方根可能会有问题，为什么?有什么办法可以解决?

解答见[prime_one.py](https://github.com/dengshilong/C100Problem/blob/master/chapter2/prime_one.py)

## 2.4 筛法(SIEVE)
求质数是一个很普遍的问题, 通常不外乎用数去除, 到除不尽时, 给定的数就是质数。但是早在2000年前人们就知道了一个不必用除法而找出2~N的质数的所有方法了。假设有一个很神奇的筛子, 可以给出一个数,例如 i,这个筛子有办法把 i 的所有倍数去掉。请用这个方法求出2~N之间的所有质数。这个方法称为 Eratosthenes(人名)筛法(Sieve Mothod)

说明:下面通过一个例子来加强对筛法的印象,求出2~40之间的质数。首先,把2~40这
些数一字排开:

2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40

2是质数, 所以把2的倍数都筛掉

3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39

下一个数自然是质数3, 所以把3的倍数都筛掉

5 7 11 13 17 19 23 25 29 31 35 37

下一个是5, 把5的倍数筛掉

7 11 13 17 19 23 29 31 37

下一个是7, 把7的倍数筛掉(其实在此之前都已经筛掉了)

11 13 17 19 23 29 31 37

再下来是11, 比20/2大了, 所以工作停止, 没有被筛掉的就是质数, 它们是2,3.5,
7,11,13,17,19,23,29,31,37。

可以按照这一逻辑来编写程序,但是需注意下面几点:

1. 2是质数,所以2的倍数是一定会被删除的,所以在一开始时根本没有把2的倍
数放到筛子中的必要,这就省下了一半的空间。

2. 如果要求2~N之间的质数,做到N/2就可以停下来,因为大过N/2的数都不可
能整除N

3. 程序不可以使用乘法与除法,只能用加或减,以求加快速度。

请基于这3项要求来编制程序。

解答见[sieve.py](https://github.com/dengshilong/C100Problem/blob/master/chapter2/sieve.py)

## 2.6 因子分解(FACTOR)

编写一个程序, 读入一个正整数, 把它的所有质因子找出来。例如, 如果输入的是72 = (2 ^ 3) * (3 ^ 2),于是质因子就有 2 与 3, 如果输入的是181944, 181944 = (2 ^ 3) * (3 ^ 2) * 7 * (19 ^ 2), 因子为2、3、7与19。为了方便起见,(2 ^ 3) * (3 ^ 2) * 7 * (19 ^ 2)可以用2(3)3(2)7(1)19(2)作为输出形式, 也就是说,如果分解开来有a ^ b,输出时就是a(b)。

说明: 传统的做法是把输入值(假设是n)用2去除,一直到除不尽为止。如果一共除了i次就有2 ^ i这一项,输出中就会出现2(i); 接着再用3去除、5去除、7去除等,直到商数变成1为止。以181944为例,第一次用2除得到93972, 再除一次是46896, 第三次得到23493,于是2就不能整除了。下来用3去除, 第一次得到7831, 第二次是2527, 第三次就不能整除。对于2527而言, 用7去除得到361, 再用7就除不尽了, 其次的11、13、15、17也都除不尽; 但19可以, 再用19去除得19; 最后用19除, 商为1, 不能再除了,因此就得到181944 = (2 ^ 3) * (3 ^ 2) * 7 * (19 ^ 2)的结果。试用这个概念来编写程序。

解答见[factor.py](https://github.com/dengshilong/C100Problem/blob/master/chapter2/factor.py)


## 2.7 数值自乘递归解(RecursionPower)
如果n与m是正整数, 那么m ** n 就是把m连乘n次, 这是一个效率很低的方法，请写一个计算效率高的程序 ，并且分析城中一共用了多少个乘法，应该以n - 1个乘法作为设计准则。

说明: 这是一个典型的递归设计题目，应该注意一下几点

1. 试用分而治之(Divide and Conquere)的策略
2. 注意到x ^ 4可以用x ^ 2自乘的关系，由此可以大量地降低乘法数目
3. 连乘n次要n - 1个乘法，能做到只要2log(n)个乘法吗？

解答见[recursion_power.py](https://github.com/dengshilong/C100Problem/blob/master/chapter2/recursion_power.py)

## 2.8 数值自乘非递归解( IterationPower)
继续求m ^ n 问题(m与n是正整数)。前面的数值自乘递归解会得到一个递归的程序,请编制一个运算效率同样高的非递归的程序。

说明: 或许读者有自己独特的看法, 但在此提供一个简单的建议, 可以采用它来编写程序, 当然也可以把它化简。建议是把指数n用二进制来看, 比如若n=13, 那么13(10进制)=1101(2进制)=2 ^ 3 + 2 ^ 1 + 2 ^ 0, 所以求m ^ (2 ^ 3 + 2 ^ 1 + 2 ^ 0)时就相当于求m ^ (2 ^ 3) * m ^ (2 ^ 2) * m ^ (2 ^ 0);会发现二进制表示中对应那一位是1, 在m中就有那么一项。把这个观念编制成程序。

另外一个办法是可以把递归解法中每一个递归步骤的n提出来,看在什么时候用(m ^ k) ^ 2,什么时候用m(m ^ 2k),然后用非递归方式写出来。

了解了这些观点之后,编写这个程序就不难了。在编写完程序之后,还应该分析一下程序乘了多少次。

解答见［iteration_power.py](https://github.com/dengshilong/C100Problem/blob/master/chapter2/iteration_power.py)

## 2.9 Fibonacci数非递归解(IterationFibonacci)
Fibonacci数列f(1),f(2),...,f(n)的定义是:

1. f(n) = 1 当 n = 1或n = 2时
2. f(n) = f(n-1) + f(n-2) 当n > 2时

不用递归的方法, 也不用数组, 编写一个函数, 它接收n的值, 返回f(n)。

说明: 用递归方法算 Fibonacci数列效率是很低的, 要计算很多个重复的加法, 这个题目要求不用递归, 不用数组, 把f(n)求出来。 不过应注意下面的事项:

1. 递归方式并非全然不好,但不能直接套用公式。
2. 因为当n > 2时,f(n) = f(n-1) + f(n-2),所以程序只保留f(n-1)与f(n-2)就可以算出f(n)。

解答见[iteration_fibonacci.py](https://github.com/dengshilong/C100Problem/blob/master/chapter2/iteration_fibonacci.py)

## 2.10 快速Fibonacci数算法(FastFibonacci)

继续讨论Fibonacci 数列问题。在非递归的Fibonacci 程序中，在算f(n)时最多不超过n - 2个加法, 编写一个速度更快的程序，或许可以用乘法。如果每一个乘法用m单位时间, 每一个加法用p单位时间，于是非递归的写法因为最多有n - 2个加法，因此最多用(n-2)p时间。请问，改善的程序要用多少时间？假设只考虑加法与乘法而已。

说明: 解决这个问题的技巧不少，在此先提示一个很容易理解的方法。用矩阵来算，看下面的式子:

(f(n), f(n-1)) = ((1, 1), (1, 0)) * (f(n-1)), f(n-2)), n > 2
相信不难看出这个式子是对的，其实这只不过是把: f(n) = f(n-1) + f(n-2), f(n-1) = f(n-1)写成矩阵的形式而已。

将上式展开:
(f(n-1),f(n-2)) = ((1, 1), (1, 0))*(((1, 1), (1, 0)) * (f(n-2), f(n-3))) = ((1, 1), (1, 0)) ^ 2  * (f(n-2), f(n-3))

一般而言，有:
(f(n), f(n-1)) = ((1, 1),(1,0)) ^ i * (f(n-i), f(n-i-1))
继续展开会得到:
(f(n), f(n-1))=((1,1),(1,0))^(n-2) * (f(2), f(1)) = ((1,1),(1,0))^(n-2) * (1, 1)

可以用这个观点来编写程序。

解答见[iteration_fibonacci.py](https://github.com/dengshilong/C100Problem/blob/master/chapter2/fast_fibonacci.py)

## 2.11 扩充Fibonacci数(ExtendFibonacci)

定义一组称为扩充的Fibonacci数如下:
已知X 与 Y两个数, 于是扩充Fibonacci数F(i)为
F(i) = 1 当i=0或者i=1, F(i) = X * F(i-2) + Y * F(i-1) i > 1
因此，当X=Y=1时，这一组扩充的Fibonacci数就变成一般的Fibonacci数，现在请编写一个函数，接收一个n值，不用数组与递归的方法算出下面的结果:
F(0).F(1) + F(1).F(n-1)+...+F(i).F(n-1)+...+F(n-1).F(1)+F(n).F(0)

说明:与许多求某个式子的和的程序一样，也不能马上下手编写程序。因为数学家用的式子与编写程序的式子不同, 数学家讲求式子要能表达出原意, 而编程的式子则要求好算, 不仅如此,还要运算得快。 如果用上面的式子, 为了要用到F(0)与F(n),可能要用一个数组把F(0), F(1), F(n)算出来后保存起来, 再两两相乘、相加。这种方法固然不错, 但当n比较大时,内存的要求就大了,所以限定不能用数组.

因此, 这里的提示是把式子换个面目,看有没有办法实现不用递归来算 Fibonacci数的程序。

## 2.16 连续整数的固定和(GivenSum)

编写一个程序, 读入一个正整数, 把所有那些连续的和为给定的正整数的正整数找出来。例如,如果输入27, 发现2~7、8~10、13与14的和是27, 这就是解答:如果输入的是10000, 应该有18~142、297~1328、388~412、1998~2002这4组。注意, 不见得一定会有答案,譬如说4、16就无解; 另外, 排除只有一个数的情况, 否则每一个输入就都至少有一个答案, 就是它自己.

说明: 任何人看到这个题目都会马上想到一个办法, 把所有的和算出来, 与输入比较。曾经看到过如下的一个解法, 如下程序所示

```
def bad_given_sum(n):
    result = []
    mid = int(n / 2)
    for i in range(1, mid + 1):
        s = i
        for j in range(i + 1, mid + 1 + 1):
            s += j
            if s == n:
                result.append((i, j))
    return result
```

它的做法是先固定一个i, sum变量, 接着令j 从i + 1起变化, 每次都把j的值加到sum 中，
因此sum中的值就是i, i + 1,...,这些连续整数的和. 因此令i 从1 编导n / 2(n是给定的数), 而j从计1变到n / 2 + 1, 如果有一个和与n相同, 就显示i与j,表示n的值是i到j这一串连续的正整数的和。为什么i要从1到n / 2? 很简单, 如果i是n / 2,下一个数就是n / 2 + 1, 于是这两个(连续的)数的和n / 2 + (n / 2 + 1) = n + 1就大于n, 所以i最多只能到n / 2; 同理可以说明j 不可以大过n / 2 + 1

这个程序当然是对的, 但运行太慢了! 用10000作为输入, 它一共执行了311.71秒, 也就是5分钟多: 但事实上, 这个题目可以在不到一秒之内得出答案, 而且当输入1000000(100万)时,也不过用178.12秒(3分钟)左右而已,相比之下bad_given_sum的效率实在太低了。(本书写于1988年，那时候计算机性能还不够好)

问题出在什么地方? 加法次数太多了。在上面的程序中, i与j的关系永远满足1 <= i <= n / 2, i + 1 <= j <= n / 2 + 1, i < j, 每一组i与j都会做一次加法,所以就一共做了大约n ^ 2 / 8个加法(这是个近似值); 当n = 10000时,就大约是1250万个。

不过, 一个好程序员应该研究是否有更好的方法存在, 事实上就有一个, 大约需要2n
个加法就足够了, 能想得出来吗? 下面是几点有用的提示:

1. 如果在求和时是用i + (i + 1) + … + j表示, 那么 i <= n / 2; 这是上面提过的。
2. 如果某个和i + (i + 1) + … + j比给定的值大, 那么把和变小, 但仍然维持是一串连
续整数的和时, 拿掉j变成i + (i + 1) + … + (j - 1),不如拿掉i变成(i + 1) + … + j。为什么? 因为j比i大, 拿掉j, 和就下降太快了, 不如拿掉i, 再慢慢降低(能用数学来证明吗?)
3. 如果和i + (i + 1) + … + j比给定值小, 加上j + 1变成的i + … + j + j + 1; 道理同前。

有了这几点, 编程应该不会是件难事了。

解答见[given_sum.py](https://github.com/dengshilong/C100Problem/blob/master/chapter2/given_sum.py)

# chapter3

## 3.1 列出所有子集(DIRECT)

编写一个程序,列出{1, 2, 3, … , n}这个集合的所有子集, 包括空集合.

说明: 列出一个集合的所有子集有很多做法,题目中并没有要求依某个特定的次序来排列,
因此是不难做出来的。 因为集合中一共有n个元素,所以总共就会有2 ^ n 个子集; 例如{1, 2, 3} 有如下子集: {} {1} {2} {3} {1, 2} {1, 3} {2, 3} {1, 2, 3}

解答见[direct.py](https://github.com/dengshilong/C100Problem/blob/master/chapter3/direct.py)

## 3.3 产生Gray码(GrayCode)
编写一个程序, 用Gray码(Gray Code)的顺序列出一个集合的所有子集。
说明: 这个问题其实是在看有没有办法把Gray(人名)码用程序编写出来, 有了Gray码，找出对应的集合是件简单的事。

什么是Gray码? nbit的Gray码是一连串共有2 ** n 个元素的数列, 每一个元素都有能nbit, 而且任何相邻的两个元素之间只有1的值不同, 例如,3个bit的Gray码:

> 000 001 011 010 110 111 101 100

是一组Gray码, 任何相邻两个元素都只有1bit值不同。但是，Gray码却并不是惟一的，把它循环排列或是用反过来的顺序写,也会得到一组Gray码; 比如说, 如果把最后3个素放到最前面去, 就会得到

> 111 101 100 000 001 011 010 110

也是一组Gray码。

产生Gray码的方法很多，这里这介绍其中一种。
将2bit Gray码列出
00
01
11
10
将3bit Gray码列出
000
001
011
010
110
111
101
100
观察3bit Gray码可以发现，它可以由2bit Gray码来得到。

解答见[gray_code.py](https://github.com/dengshilong/C100Problem/blob/master/chapter3/gray_code.py)



## 3.5 产生所有排列字典顺序(RecursionPermutation)
若编写一个程序,用字典顺序列出n个元素的所有排列(Permutation)


说明:
下面是一个n = 4，用字典顺序列出来的所有排列，一共为4! = 24个。

1234 2134 3124 4123

1243 2143 3142 4132

1324 2314 3214 4213

1342 2341 3241 4231

1423 2413 3412 4312

1432 2431 3421 4321

字典顺序的先后是这样定义的, 如果a(1)a(2)…a(n)与b(1)b(2)…b(n)是n个元素的两个排列
于是有a(1)=b(1), a(2)=b(2),...a(i)=b(i),但a(i+1)<b(i+1), 就是说a(1)a(2)a(n)。在b(1)b(2)b(n)的前面,或者说前者较"小"; 注意,自i+2个之后的各个元素是没有影响的。其实, 这就是用来决定字符串大小的方式。举例而言, 2314与2341,前两个元素相同,但第三个为1<4,所以2314在前, 2341在后; 同理, 1234与4321相比, 1234在前,4321在后。

如何产生字典顺序的排列呢? 据Hall与 Knuth的考证, 200年(1812年)前Fischer与Kruse在他们的一本书中就已经提过这样的方法了。从1234…n开始,首先从右到左出第一对满足a(i)<a(i+1)n的a(i)与a(i+1),于是从a(i+1)起在它右边的就是越来越小的:有了a(i)之后再一次地从右到左查一次, 找出第一个满足a(i)< a(j)的a(j)。接着把a(i)到a(j)的各个元素反过来排, 就是字典顺序的下一个了。下面来看看如何找出153642的下一个:从右到左第一组满足a(i) < a(i+1)的是3与6,所以a(i),就是3。接着从右到左去找第一个a(j),使得a(i) < a(j),则是3 < 4; 把a(i)和a(j)换下位置，最后把a(i+1)与a(n)之间的元素反过来排,因此得到154236,这就是结果。

看另一个递归的做法。看上面4! = 24个排列的第一列，它们的第一个元素都是1，第一列的最后一个是以1开头，用字典顺序排出来的最后，自然是1432.事实上，如果是n个元素的排列，以1开头的最后一个应该是1n(n-1)…432。下一列是2开头，把n(n-1)…432中最小的一个与第一个互换，也就是把倒数第一个与第一个互换，得到2n(n-1)..431，但这不是1n(n-1)…432的下一个，但是如果把后面的n - 1个元素反过来，就会得到2134…(n-1)n，是正确的顺序，于是进入第二列。

第二列的最后一个应该是2n(n-1)…431,把 n(n-1)…431中最小的与第一个互换，但因为1已经出现过了，所以把倒数第二个元素(自然是3)与第一个互换，得到3n(n-1)…421，再把后面的n - 1个元素反过来，得到3124…(n-1)n，就得到第三列的第一个。

第三列的最后一个是3n(n-1)…421, 把n(n-1)…421中最小的与第一个互换，但因为1，2已经出现过了，所以把倒数第3个元素(自然是4)与第一个互换，得到4n(n-1)…321，再将后面n - 1个反过来排，得到4123…(n - 1)n，正好是第4列的第一个元素。

于是我们可以得到一个递归的做法，从1234…n起，用一个递归的程序

1. i = n
2. 对后面n - 1个进行排列(递归的)
3. 把第i位与第1位互换
4. i减去1
5. 把后面的n - 1位反过来排
6. 回到第2步

当i到第一位时程序结束。

解答见[recursion_permutation.py](https://github.com/dengshilong/C100Problem/blob/master/chapter3/recursion_permutation.py)


## 3.8 整数的所有不同分割数目(IntegerPartition)
所谓的整数的分割(Partition of an Integer), 指的就是把一个正整数写成若干个正整数的和，但这里只计较有多少种分割方式，而不计较它的内容。例如，4=3+1,2+2,2+1+1,1+1+1+1+1, 再加上自己，就一共有5种分割方式。编写一个程序，输入一个正整数，输出它有多少种分割方式。

说明: 以下是几点重要的提示

1. 要把n进行分割，其实不完全只针对n, 还要看分割中最大的值是什么。例如，要把10进行分割，若在分割中最大的值是6，即10=6+..., 那么"..."的部分充其量的值是4而已，不仅如此，和还须等于4；因此，如果知道"...", 即4有多少种分割方式，也正是在分割10时，最大值为6的分割方式！
2. 应该分析一下n这个输入值，与在分割中的极大值(如1.中的6)之间有什么联系，找出来，问题就解决了。
3. 不要忘了，递归是非常有效的武器

解答见[integer_partition.py](https://github.com/dengshilong/C100Problem/blob/master/chapter3/integer_partition.py)

## 3.9 整数的分割方式(IntegerPartitionII)

对于一个正整数n而言，它的一个分割(Partition),就是把n写成若干个正整数的和，但不计较书写的顺序。编写一个程序，输入n，把n的所有分割显示出来。
说明: 如果n=7, 那么有如下的分割.
> 7
> 
> 6 1
> 
> 5 2
> 
> 5 1 1
> 
> 4 3
> 
> 4 2 1
> 
> 4 1 1 1
>
> 3 3 1
> 
> 3 2 2
> 
> 3 2 1 1
>
> 3 1 1 1 1 
>
> 2 2 2 1
>
> 2 2 1 1 1 
>
> 2 1 1 1 1 1 
> 
> 1 1 1 1 1 1 1

一共有15个，仔细观察在各个输出中前后两者的差异，并且自己做一做其他的结果(比如n=5时有7个，n = 6时有11个等),就不难写出程序了。

解答见[integer_partition_method.py](https://github.com/dengshilong/C100Problem/blob/master/chapter3/integer_partition_method.py)


## 4.1 寻找脚码(IndexSearch)
已知一个整数数组x[], 其中的元素彼此都不相同,而且也已经从小到大排列好,请用
比较大小、相等的方式编写一个程序, 找出给定的数组中是否存在一个元素满足x[i] = i的关
系。举例而言, 如果x[]={-2,-1,3,7,8}, x[3] = 3, 因此 3 就是答案, 因为编程语言中数组是从0开始的，所以最终是检测是否存在一个元素满足x[i] = i + 1.

说明: 用笨方法, 一个循环就可以找出答案, 如下程序所示

```
def bad_index_search(x):
    index = -1
    for i in range(0, len(x)):
        if x[i] == i + 1:
            index = i + 1
            break
    return index

if __name__ == "__main__":
    x = [-2, -1, 3, 7, 8]
    print(bad_index_search(x))
```

这个程序在最坏的情况下, for一共绕了n圈, 作了n次比较, 但却没有用到x[]的元
素已经排列好的条件. 事实上, 如果输入有n个元素, 应该可以写出与log(n)次成正比的比较的程序,关键是x[]的元素是排好顺序的。

解答见[index_search.py](https://github.com/dengshilong/C100Problem/blob/master/chapter4/index_search.py)

## 4.7 3个数组的共同元素(SearchThree)
有3个数组x, y 与 z, 各有x, y 与 z 个元素, 而且三者都已经从小到大依序排列。编写一个程序, 找出值最小的共同元素(也就是同时在3个数组中出现, 并且值最小的元素); 但若没有共同元素, 请显示合适的信息。

说明: 通常寻找数据的工作都是给了一个数据, 看看在某个数组中有没有它, 但是这个问题却是另一个目的, 要找出一个共同的元素。 其实在实际应用中这种类型是屡见不鲜的。例如, 警察知道犯人是合北市人, 有大学学历, 有窃盗前科, 因此就可能从台北市得到这个台北人的档案, 从教育部取得历年大学毕业生的档案, 再从警察局取得有窃盗前科的人的档案, 如果这些档案已经依人名从小到大排好了, 那么找出嫌疑人的工作就与本题差不多所不同的是: 第一, 只要找出第一个, 而警察局可能要找出所有的; 第二, 用数组处理,所以得知该元素个数, 而警察局收到的是档案, 也许不知道各个档案有多少笔数据而已。因为不知道要找的是什么, 所以二分查找法没有多大用处, 要另外想办法来解题, 据我所知,最多用3min(x, y, z)次比较就可以决定答案, 更重要的是程序将不超过10行, 所以要往深处思考。

## 4.9 查找矩阵(MatrixSearch)
已知一个n列n行的矩阵M,它的元素满足一个很特殊的性质, 即任一元素M[i][j]都小
于在它右边与下方的元素(如果存在的话), 换言之,M[i][j] < M[i][j+1]且M[i][j] < M[i+1][j]. 现在有一个值K, 编写一个程序, 检查矩阵M中是否有K。

说明: 这个矩阵有了一种很特殊的结构, 换言之, 每一列与每一行都从小到大排列, 所以做寻找的工作时就可以通过这个特殊的顺序来编写程序。注意, 虽然有n ^ 2个元素, 但理论上可以证明, 在最坏的情况下, 2n - 1就可以决定K在不在M中; 关键所在, 就是如何模仿二分查找法的技巧在一次比较之后就尽可能去掉多余的元素.

解答见[matrix_search.py](https://github.com/dengshilong/C100Problem/blob/master/chapter4/matrix_search.py)

## 6.9 最长公共子序列(LongestCommonSubsequence)
如果A=a[1]a[2]...a[m]是一个长度为m的字符串, 把其中的若干(可能是0个, 也可能是n)个符号去掉, 而得到一个新字符串, 这个新字符串就称为A的子序列(Subsequence). 例如, 若A=abc0123, 那么b02, abc123, b3, c, ab0123, ab12等都是A的部分序列.

假设给出两个字符串A与B, 长度分别是m与n, 那么A与B就含有若干共同的子序列, 至少虚字符串(或说是空字符串)就是一个共同部分序列; 所谓C是A与B的公共子序列, 指的是C是A的子序列, C也是B的子序列。编写一个程序,把A与B的公共子序列中最长的那一个找出来。

这个问题一般都称为最长公共子序列(Longest Common Subsequence)问题, 简称为LCS

说明: 这是一个非常有名的题目, 而且是一个分支中的主要问题, 这个分支称为字符串匹配(String Matching), 可以说是计算机科学研究领域中比较早开发的科目, 目前的应用很广, 从语音分析到生化都能看到这一支的踪迹, 参看下面参考文献中各篇文章的介绍. 写程序的熟手或了解算法理论的朋友是不难写这个程序的, 因为它不过是一个动态规划(Dynamic Programming)的应用而已。给一点提示, 如果两个字符串是A=a[1]a[2]…a[m], B=b[1]b[2]...b[n],考虑a[i]与b[j]
 
如果在a[1]a[2]…a[i-1]与b[1]b[2]…b[j-1]这两个字符串的前段中已经找到了一个长度是k的公共子序列, 那么会有两种可能:

1. 如果a[i] = b[j], 于是把原来长度为k的共同部分序列后面补上a[i](或b[j], 哪一个无所谓, 因为两者相同), 就会得到a[1]a[2]…a[i]与b[1]b[2]…b[j]的一个长度是k+1的公共子序列
2. 如果a[i] != b[j],分成两种情况讨论: 第一, 检查a[1]a[2]...a[i-1]与b[1]…b[j-1]b[j]的最长公共子序列的长度; 第二, 检查a[1]…a[i-1]a[i]与b[1]b[2]...b[j-1]的最长共同部分序列的长度。最后进行适当的处理。

有了这个观点在心中, 找出最长公共子序列应该不会十分困难, 但是要如何把那个序列找出来呢? 这或许要好好想一想。

下面推荐的这本书是论文集有许许多与编修字符串方面的文章可供参考, 自然也包含有最长共同序列这个问题:此外,书中还有不少这些方面的应用与说明。

R.A. Wagner and M.J. Fischer. The String-to-String Correction Problem, Joumal of ACM。Vol.21(1974) p168~173

解答见[longest_common_subsequence.py](https://github.com/dengshilong/C100Problem/blob/master/chapter6/longest_common_subsequence.py)

## 6.10 字符串编修(StringEdit)
已知两个字符串s与t, 要研究如何把字符串s经由一连串编修动作变成t。能够使用的就是插入一个符号, 以及删除一个符号; 把某个符号换成另一个, 就可以通过先把它删除再在原地插入所需的符号来完成。编写一个程序, 接收s与t, 找出如何才能够在最少步骤之下把s改成t。

说明: 把一个字符串修改成第一个字符串在语汇分析(Lexical Analysis)与拼字分析(Spelling Check)中有很重要的地位。例如, 已知s这个字符串可能有问题, 而在s中应该会出现t[1],t[2]…t[k], 这几个字符串其中之一, 但是用哪一个比较好呢? 通常会选使用最
少修动而能够把s改出来的那一个, 这一项技巧在化学中研究分子结构相当有用.

如果已知ABCD这个字符串,想把它改成XBYD,一看就知道可以把A换成X, C成Y就行了, 这就有了4个动作一删除A, 插入X,  删除C, 插入Y; 但也可以把ABCD全部删除,再插入XBYD, 这就要8个动作, 4个删除, 4个插入。当然, 两者相比, 自然是第一个方法好些。这是一个简单的例子, 但当s与t这两个字符串很长时就不那么容易看出结果了, 因此这个题目就是要求编写这样的一个程序.

前面的最长部分序列(Longest Common Sequence)的技巧对本题非常有帮助, 不妨先看看LCS这个程序

a[1]a[2]...a[i]与b[1]b[2]...b[j]相互变换可以分为以下几种情况

1. 如果a[i] = b[j], 于是a[1][2]...a[i]变成b[1]b[2]...b[j]的次数等于a[1]a[2]...a[i-1]变成b[1]b[2]...b[j-1]的次数
2. 如果a[i] != b[j], 分成三种情况讨论: 第一, 检查a[1]a[2]...a[i]变成b[1]…b[j-1]后，再插入一个b[j]; 第二, 检查a[1]…a[i-1]变成b[1]b[2]...b[j]后再插入一个a[i]; 第三: a[1]...a[i-1]变成b[1]b[2]...b[j-1]后，删除a[i], 插入b[j]

解答见[string_edit.py](https://github.com/dengshilong/C100Problem/blob/master/chapter6/string_edit.py)

## 7.2 三色旗问题(ThreeFlag)
假设有一个数组, 它有n个元素,每一个不外乎是红、白、蓝3种颜色之一的代号, 就说是R, W, B好了。这些元素在数组中并没有依同样颜色的元素排在一起的方式来排列, 请写一个程序把这些元素排成所有蓝色在前, 然后是白色, 最后是红色的排列方式, 不过在写程序时要满足下面的条件

1. 不能用到额外的内存,换句话说,只能在数组之内用互换的方式完成。
2. 互换两个元素的动作要越少越好
3. 对于每一个元素而言,测试它是红, 白, 还是蓝的工作, 每种颜色最多只能做一次测试

在这个限制之下,请编写一个最快的程序

说明: 有些人很自然地会想到把蓝色当成1、白色当成2、红色当成3, 然后用排大小的程序把次序排出来,自然地蓝色在前, 白色居中, 红色最后了; 完全正确, 不过却违背了规定。也就是说, 互换两个元素的动作是不是太多了呢? 对每一个元素测试它的颜色的行为是否违反了要求呢? 对前者而言,不同的排序方法会有不同数目的互换动作。比如说,如果用选择法, 每次找到计i+1 ~ n中最小的值, 与第i个元素互换, 那么排序的动作只不过用了n-1次互换。但是对第三个限制而言, 就很难保证对每一个元素、每一种颜色都最多只测试次了

第三个条件需要仔细地说明, x[i]表示第i个元素。第三个条件是说, x[i] == R, x[i] == W, x[i] == B 这3个比较的任何一个都最多只能做一次。举个例子, 如果在决定观应该放在什么地方时,上述3个比较都各做一次,是正确的。任取两个或任取一个各做一次,也是正确的。但x[i] == R、x[i] == W、x[i] == R就是错的了, 因为对R的测试做了两次。

其实这个题目并不难, 把数组从头到尾查一次就可以做出结果, 那3个繁琐的条件, 不过是防止去用排序或“不够快”的方法来解题而已。

解答见[three_flag.py](https://github.com/dengshilong/C100Problem/blob/master/chapter7/three_flag.py)

## 7.8 找零钱问题(MakeChange)
某个国家一共发行了a1, a2, a3, …, ak种不同面额的钞票, 为了方便起见, 假设
a1 < a2 < … < ak· 现在手上有n, 请问要如何把n兑换成a1, a2, a3, ……, ak这些钞票,使得所用钞票的量为最少

说明: 先说一个最常见的例子, 如果有1元、5元、10元3种, 而又有107元要兑换, 于是a1=1, a2=5, a3=10, n=107。兑换方式很简单, 用面额最大的去除, 那就是最大面额钞票的张数, 比如说n/a3 = 107/10 = 10,亦即10元的10张; 除过之后就会有余数7, 再用次大面额的钞票去除, 得商数1(7/5 = 1), 余数2, 所以5元的一张; 再把余数用第三大面额去除
(2/1)得商数2, 余数0, 于是1元的两张, 但余数为0, 于是就没有剩下来的钱了, 因此最后结果是10元10张, 5元1张, 1元两张。假若n=78, 那就是10元7张, 5元1张, 1元3张, 一般书中就是这样讲的, 不过对1元、5元、10元这个例子而言, 倒也是正确。如果钞票的面额是1元、3元、4元(奇怪的数字,是吧?), 要兑换10元呢? 用上面的方法, 有4元两张(104=2,余2)、1元两张, 一共用了4张钞票。但若用两张3元、1张4元, 也兑出了10元, 却只用了3张钞票. 

这个例子说明, 寻常所用的方法固然可以兑换钞票, 但钞票张数却不是最少的; 此外问题是, 请写一个程序, 输入a1,a2…, ak钞票面额, 以及n个欲兑换的钱数, 输出钞票张数最少的兑换方式。

解答见[make_change.py](https://github.com/dengshilong/C100Problem/blob/master/chapter7/make_change.py)


## 7.12 产生匹配括号的字符串(GenerateParenthesis)
请写一个程序, 输入一个正整数的值, 然后列出所有由n个左括号与n个右括号正确成的字符串; 当然, 正确的左, 右括号一定个数一样多, 所以输入的值要是个偶数

说明: 所谓由括号正确地组成的字符串, 指的是如果有一个左括号, 那么在它的右边就一定有一个与它相匹配的右括号。例如,()()、(()),就是仅有的两个有4个符号的, 由括号正确地组成的字符串:()()()、()(())、(())()、(()())、((()))则是5个有6个符号, 由括号正确地组成的字符串。正因为有一个左(或右)括号就一定有相对应的右(或左)括号, 左、右括号成双出现, 因此输入就一定要是偶数, 奇数是不可能的。当输入n之后, 在字符串中左、右括号的个数就各是n/2个。

如何产生这样的字符串呢？下面就是一个有用的想法：如果在产生的过程中已经产生了若干左、右括号，为了要把产生的行为完成，还欠R个左括号、L个右括号，那么有没有办法找出产生下一个括号时L与R的关系呢？记住，递归是一个不容忽视的利器。

解答见[generate_parenthesis.py](https://github.com/dengshilong/C100Problem/blob/master/chapter7/generate_parenthesis.py)

## 8.5 N后问题递归解(NQueen)
8后问题(Eight Queen Problem)是指在一个8 * 8的西洋棋盘上要如何放置8个皇后棋, 且不会互相吃到对方; 皇后棋可以吃掉任何它所在的那一列、那一行, 以及那两条对角线(米字型)上的任何棋子。请写一个程序, 读入一个值n表示棋盘的大小, 然后求出n * n格棋盘上放n个皇后棋且不会相互吃掉对方的所有解答。

说明: 这是广义的N后问题, 因为所要求的是“所有”解答, 而不单是其中的一组, 对大多数会运用递归的人来说,这个题目反而容易做些。这一类型题目的解法通常要用到回溯(Backtrack)的技巧, 不管用递归还是不用递归都是如此, 虽然会浪费时间,但多半会找到解答。

回溯的技巧通常都以下面的面目出现, 如下所示。

```
S = 目前可以用得到的位置;
当S非空: 
	取出S中一个元素, 令为s
	如果s可以安全使用，那么
		定出s已经使用
		如果还可以从S再进一步，那么
			用S调用自己
		如果已经有了答案，那么
		   显示答案
		把s定成没有在使用
```

解答见[n_queen.py](https://github.com/dengshilong/C100Problem/blob/master/chapter8/n_queen.py)

## 8.9 非递归汉诺塔(HanoiTower)
汉诺塔(Towers of Hanoi)是一个在入门书籍中常见的例题或习题, 它是说: 有3根柱子, 1、2与3,在柱子1上串了从上到下编号是1, 2, …, m的圆片, 号码小的圆片包小. 问题是, 请写一个程序,把柱子1上的圆片搬到柱子3去。在搬的时候有3个要求:第一, 每次只能搬一个圆片; 第二, 要搬的圆片得从某个柱子取出, 并且放到另一根柱子上; 第三,任何时刻、任何柱子上的圆片, 从上到下都是从小到大排列。书上的解法都是递归的, 请写一个非递归且不用堆栈来仿真的程序.

说明: 如果用教科书中的解法, 那么递归是个非常好且效率非常高的技巧, 程序大致如程下

```
#coding: utf-8

def hanoi_tower(n):
    return _hanoi_tower(n, 1, 2, 3)


def _hanoi_tower(n, start, mid, end):
    if n == 1:
        print("Move disk %d from %d to %d" % (n, start, end))
    else:
        _hanoi_tower(n - 1, start, end, mid)
        print("Move disk %d from %d to %d" % (n, start, end))
        _hanoi_tower(n - 1, mid, start, end)


if __name__ == "__main__":
    hanoi_tower(3)
```

这个观点是, 先把在start柱子上的n-1个圆片搬到mid柱子上去(用end柱子作中继站), 于是在strt柱子上就留下3在最下方, 也就是最大的一个圆片, 即第n号, 把它从start搬到end去(见print); 现在的情况是, 最大的已经到了目的地, 但在上方的第1 ~ n－1号还停留在mid柱子上; 第三步就是把mid上的n-1个圆片搬到end柱子上, 用start柱作中继站。当然, start、mid、end就是题目中的3根柱子, n是要搬的圆片数目.

递归的解不但漂亮, 而且容易懂; 不过了解了递归解法之后产能够由它而发展出一个非递归的解吗? 当然, 用堆栈来仿真并不是所期望的, 应该把递归动作中在什么时候搬那个圆片, 从何处搬到何处这一层关系弄清楚, 那么问题就不难了。


## 9.6 最大连续元素和(MaximuConsecutiveSum)
已知数组x[]储存了一组整数, 请写一个程序, 找出在数组中连续元素的和中最大的一个。举例而言, 如果有数组[1, 2, -6, 3, -2, 4, -1, 3, 2, -4], 那么连续的元素的和有1 + 2 = 3, 1 + 2 + (-6) = 3, 2 + (-6) = 4, ..., 但值最大的就是3 + (-2) + 4 +(-1) + 3 + 2这一段, 值为9. 规定: 和为负值时就定成0, 所以结果永远不为负。这个题目通常叫做最大连续元素和(Maximum Consecutive Sum)问题
说明: 这个问题有个很简单的解法, 但效率很低, 一般采用效率很高的方法的程序比使用不
好的方法的要长。一般人看到这个问题的自然反应就是用两个循环, 如程序所示。

```
def bad_method(x):
    max_sum = 0
    for i in range(len(x)):
        s = 0
        for j in range(i, 0, -1):
            s += x[j]
            if s > max_sum:
                max_sum = s
    return max_sum
```

想法是很简单的, 当固定在某个x[i]之后, 把x[i], x[i-1] + x[i], x[i-2] + x[i-1] + x[i], ... x[0] + x[1] + ... x[i]求出来, 一边算, 一边找出极大值, 这就是上面片段所隐含的意义。但是, 当处理到i时要查i个元素, 所以要把n个数都处理完,就要查1 + 2 + 3 + … + i + ... + n = n(n+1)2、与n ** 2成正比的元素了。如果仔细看就会发现做了很多重复的工作, 为什么? 当i是2时,算了x[2], x[1] + x[2], x[0] + x[1] + x[2], 但当i进到下一个位置变成3时, 又算x[3], x[2] + x[3], x[1] + x[2] + x[3], x[O] + x[1] + x[2] + x[3], 于是x[1] + x[2] 与 x[O] + x[1] + x[2]不都是重复算了吗? 因此, 程序如果能够避免这些重复的部分, 就一定会非常快。

解答见[maximum_consecutive_sum.py](https://github.com/dengshilong/C100Problem/blob/master/chapter9/maximum_consecutive_sum.py)

## 9.9 投票问题(Voting)

这个问题一般叫做过半数(Majority)问题, 也有人称为投票(Voting)问题, 但以前者说法居多。假设有1, 2, ... n等n个人参加投票, 他们只能圈选一个人, 但是却可以选任何一人, 甚至于可以选不在这n个人中的另一个都行。例如, 如果5个人投票, 分别投1、8、1、100、1; 1、3、5都投给1, 2投给8, 4投给100。问题是, 写一个程序接收这些投票结果, 看看有没有人的得票过半数, 就以上例来看, 1的得票数就过半数了.

说明: 这是个名题, 也与其他问题一样有简单但效率低的解法, 但也有较有技巧且效率高的做法, 简单做法是, 把投票结果先从小到大排好, 把投给同一个人的票就收在一起, 接着从头查起, 看看一连串相同的值的个数, 如果有过半数的, 那个人就当选了。用上面的例来看, 从小到大排好是1, 1, 1, 8, 100, 很显然1有3个, 过半数了, 因此1会当选。

这是一个大家都会想到的想法, 但事实上, 排大小的这一步是不必要的, 能开发出这样的程序吗? 不过要记住一点, 不能对候选人的数目作任何假设, 因为如果假定候选人是1, 2, …, k, 那么这个题目就简单至极而不会变成名题了。为什么呢? 准备一个有k个元素的
数组, 然后……(一定马上就知道是怎么回事了吧!)。

解答见[voting.py](https://github.com/dengshilong/C100Problem/blob/master/chapter9/voting.py)

## 9.11 寻找支配元素(Dominator)
已知一个整数数组x, 对于任何一个元素x[i]而言, 在x[i]右边, 而且值不比x[i]小的元素(亦即j > i而且x[j] >= x[i]的x[j])都叫做x[i]的右支配元素(Right Dominator).
在x[i]所有的右支配元素中最靠近x[i]的那一个, 就叫做最靠近的右支配元素(Right Nearest Dominator). 当然, 不见得每一个元素都有支配元素的, 如最大元素就没有,问题是, 编写一个程序, 接收一个数组, 把数组中每一个元素最靠近的右支配元素找出来

说明: 看个例子比较容易明了这个问题的要求。如果数组的内容是2, 1, 3, 5, 4那么3, 5, 4都是2的右支配元素, 但3是最靠近的一个, 所以3是2的最靠近右支配元素, 同理1与3的最靠近右支配元素分别是3与5, 5与4都没有最靠近右支配元素; 对5而言, 右边没有元素比它大;就4而言, 右边没有元素了。

看起来程序并不难写,因为可以x[1], x[2] …, x[i],…一个接一个查过去; 当查到x[i]时
就查x[i+1], x[i+2]…, 于是第一次找出比x[i]大或相等的元素, 就是x[i]的最靠近右支配元素了。但是这样的做法效率并不高。举例而言, 如果一个数组的元素是从大到小排好的但是最后一个元素是整个数组的极大值(例如,5, 4, 3, 2, 1, 6)。若数组有n个元素, 处理x[0]要比较n-1次, 处理x[1]时比较n-2次, 一般而言, 处理x[i]时要比较n - i次。所以就一共用了(n-1) + (n-2) + … + 3 + 2 + 1 =n (n-1)/2, 差不多是n ** 2次的比较.

因此, 挑战是, 能不能写出比较次数与n成正比的程序?

解答见[dominator.py](https://github.com/dengshilong/C100Problem/blob/master/chapter9/dominator.py)

## 9.12 最长递增序列(LongestIncreaseSequence)
已知一个整数数组, 在这个数组中的一个递增序列, 就是把若干元素删除后所留下的元素
按从小到大的顺序排列。举例而言, 如果数组是1,3,5,7,8,2,9,4,10,6, 那么1,5,8,9,10是个递增序列, 3,5,8,9,10也是一个递增序列, 1,3,5,7,9,10 也是递增序列。简单地说, 可以依数组元素的次序选出若干元素, 使得从小到大排好 ,那么这就是个递增序列。例如
3,8; 2,9; 7,10; 2,4,6; …。但是9,4,10; 5,7,8,2,9等却不是递增序列。 问题是, 写一个程序接收一个整数数组, 找出这个数组中最长的递增序列的长度。以上面的例子来看, 1,3,5,7,8,9,10是最长的递增序列, 所以程序输出7的结果。

说明: 递增序列的意义已如上述, 程序要如何写? 看起来似乎很难下手, 但总是有迹可寻的
为什么呢? 递增序列不会凭空出现, 一定是先有了几个, 然后又出现一个新元素, 看看
这个新元素能不能加到已有的递增序列后面, 如果可以, 已有的递增序列的长度就多了1;
但若不能添加, 那要做些什么事呢? 那就要自己想了. 先看个例子, 还是以1,2,4,3,6为例。假设目前已经发现了如下的几个递增序列:
> 1,2,4,6(长度为4)
> 
> 1,2,3(长度为3)

现在新来的元素是5, 因此5可以补在1,2,3后面而得到1,2,3,5(长度为4); 那么5对1,2,4,6的关系又如何? 这就要自己想了。

这个问题的起源可能是组合数学(Combinatoric Mathematics)。组合数学中有一个定理,
它说n ** 2 + 1个数中一定有一个长度至少为n的递增或递降序列。此处不过是要求写一个程
序把最长的递增序列的长度找出来而已, 会写这个程序之后, 递降序列也不过是同一回事。

解答见[longest_increase_sequence.py](https://github.com/dengshilong/C100Problem/blob/master/chapter9/longest_increase_sequence.py)








